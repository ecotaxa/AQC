from libQC_classes import Block, Check, ChecksLib, SubBlock
from enums import Mode, SUPPORTED_DATA_COMPONANT
import libQC_zooscan_implementation

class Lib_zooscan():

   def __init__(self):
      """Define and construct a zooscan library"""
      #Create empty QC library
      self.lib = ChecksLib()

      #Create empty Blocks 
      block_before_scan = Block("Before scan", "before_scan", Mode.HEADER)
      block_during_analysis = Block("During analysis", "during_analysis", Mode.TSV)
      block_after_ecotaxa_classif = Block("After EcoTaxa classif", "after_ecotaxa_classif", Mode.TSV)
      
      #Create empty sub blocks
      subBlock_sample = SubBlock("Sample", "This quality check gives an overview of the quality of the data related to the acquisition of the sample.", 1, "sample")
      subBlock_acquisition = SubBlock("Acquisition", "This quality check gives an overview of the quality of the data related to the acquisition of the scan on the Zooscan.", 2, "acquisition")
      subBlock_process = SubBlock("Process", "This quality check gives an overview and notes the quality of the steps performed by the sample during its acquisition (SCAN) at the Zooscan and its processing (PROCESS) via the Zooprocess application.", 1, "process")
      subBlock_multiples = SubBlock("Multiples", "toto write a description", 1, "multiples")
      

      #Create checks
      check_frame_type = Check("FRAME type", 'Displays information about the size of the frame used for scanning: "large" or "narrow".', "frame_type", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_frame_type)
      check_raw_files = Check("RAW files", "Checks the file system structure generated by zooprocess for the process and scan steps.", "raw_files", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_raw_files)
      check_scan_weight = Check("SCAN weight", "All image files _raw_1.tif inside the _raw directory must be the same size.", "scan_weight", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_scan_weight)
      check_process_post_scan = Check("Process POST SCAN", "Checks the file system structure post scan generated.", "process_post_scan", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_process_post_scan)
      check_bw_ratio = Check("B/W ratio", "In order to ensure the quality of the process, the value of the B/W ratio must be strictly less than 0.25.", "bw_ratio", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_bw_ratio)
      check_pixel_size = Check("PIXEL size", "The idea here is to reveal an old zooprocess bug that was mistaken about the pixel size to apply for morphometric calculations. The purpose is to check that the pixel_size is consistent with the process_img_resolution.", "pixel_size", 1, SUPPORTED_DATA_COMPONANT.DATA_TABLE,  libQC_zooscan_implementation.check_pixel_size)
      check_sep_mask = Check("SEP MASK", "Checking the presence of a sep.gif mask in the subdirectory of the _work. If it is not present, indicate the motoda fraction associated with the scan to eliminate the situation where there was no multiple to separate because the sample was very poor and therefore motoda = 1", "sep_mask", 1, SUPPORTED_DATA_COMPONANT.DATA_TABLE,  libQC_zooscan_implementation.check_sep_mask)
      check_process_post_sep = Check("Process POST SEP", "This second process must include the separation mask (if any) created in the previous step.", "process_post_sep", 1, SUPPORTED_DATA_COMPONANT.DATA_TABLE, libQC_zooscan_implementation.check_process_post_sep)
   
      check_sieve_bug = Check("Sieve Bug", libQC_zooscan_implementation.check_sieve_bug.__doc__, "sieve_bug", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_sieve_bug)
      check_motoda_check = Check("MOTODA check", libQC_zooscan_implementation.check_motoda_check.__doc__, "motoda_check", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_motoda_check)
      check_motoda_comparaison = Check("MOTODA comparison", libQC_zooscan_implementation.check_motoda_comparaison.__doc__, "motoda_comparaison", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_motoda_comparaison)
      check_motoda_quality = Check("MOTODA quality", libQC_zooscan_implementation.check_motoda_quality.__doc__, "motoda_quality", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.check_motoda_quality)
      check_spelling= Check("Spelling", libQC_zooscan_implementation.check_spelling.__doc__, "spelling", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 2, libQC_zooscan_implementation.check_spelling)

      checks_gps = Check("GPS", "Carte interactive, sous forme d’un Tableau, sous forme de Graphs", "GPS", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.noCb)
      checks_date = Check("Check dates de prélèvements", "", "Dates", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.noCb)
      checks_other_data = Check("Check other data", "", "other data", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.noCb)
      checks_distance_parcourue = Check("Distance parcourue par le filet", "", "distance", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.noCb)
      checks_filtred_volume = Check("Volume filtré", "", "volume", SUPPORTED_DATA_COMPONANT.DATA_TABLE, 1, libQC_zooscan_implementation.noCb)


      #Fill library with blocks
      self.lib.addBlocks(block_before_scan, block_during_analysis, block_after_ecotaxa_classif)

      #Fill blocks with subblocks
      block_before_scan.addSubBlocks(subBlock_sample)
      #block_during_analysis.addSubBlocks(subBlock_sample, subBlock_acquisition, subBlock_process)
      block_during_analysis.addSubBlocks(subBlock_acquisition, subBlock_process)
      block_after_ecotaxa_classif.addSubBlocks(subBlock_multiples)

      #Fill sub blocks with checks
      subBlock_process.addChecks(check_frame_type, check_raw_files, check_scan_weight, check_process_post_scan, check_bw_ratio, check_pixel_size, check_sep_mask, check_process_post_sep)
      subBlock_acquisition.addChecks(check_sieve_bug, check_motoda_check, check_motoda_comparaison, check_motoda_quality, check_spelling)
      subBlock_sample.addChecks(checks_gps, checks_date, checks_other_data, checks_distance_parcourue, checks_filtred_volume)

   def listChecks(self) :
      """Return an object containing all availables quallity checks"""
      return self.lib.listChecks()
   
   def runCallback(self, projects, drive, block_id):
      """Run block's QC, and return execution result as dash componants"""
      return self.lib.runCallback(projects, drive, block_id)